<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unificador de Scripts SQL</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
    <link rel="stylesheet" href="../stylesheets/themes/dark-theme-modal.css">
    <style>
        body { display: flex; flex-direction: column; height: 100vh; padding: 20px; background-color: #f8f9fa; }
        .main-content { flex-grow: 1; overflow-y: auto; border: 1px solid #dee2e6; padding: 15px; border-radius: 5px; background-color: #fff; }
        .footer-content { flex-shrink: 0; padding-top: 15px; border-top: 1px solid #dee2e6; text-align: right; }
        .script-item { display: block; } /* Garante que cada checkbox fique em uma linha */
    </style>
</head>
<body>
    <h4>Unificador de Scripts SQL</h4>
    <p class="text-muted">Selecione os scripts de atualização para combinar em um único arquivo.</p>

    <div id="scripts-container" class="main-content">
        <p>Carregando scripts...</p>
    </div>

    <div class="footer-content">
        <button onclick="window.parent.tinymce.activeEditor.windowManager.close()" class="btn btn-secondary">Cancelar</button>
        <button id="btn-gerar" onclick="generateUnifiedScript()" class="btn btn-primary">Gerar Script</button>
    </div>

    <script src="../scripts/app.js"></script>

    <script>
        const VERCEL_API_URL = 'https://auxiliar-demaria.vercel.app/api';

         let lastChecked = null;

         function handleCheckboxClick(event) {
            const clickedCheckbox = event.target;

            if (event.shiftKey && lastChecked) {
                const container = document.getElementById('scripts-container');
                const checkboxes = Array.from(container.querySelectorAll('input[type="checkbox"]'));
                const startIndex = checkboxes.indexOf(lastChecked);
                const endIndex = checkboxes.indexOf(clickedCheckbox);

                const start = Math.min(startIndex, endIndex);
                const end = Math.max(startIndex, endIndex);

                for (let i = start; i <= end; i++) {
                    checkboxes[i].checked = lastChecked.checked;
                }
            }
            
            lastChecked = clickedCheckbox;
        }

        function customVersionSort(a, b) {
            const versionA = (a.name.match(/r(\d+(\.\d+)*)/) || [])[1];
            const versionB = (b.name.match(/r(\d+(\.\d+)*)/) || [])[1];

            if (!versionA || !versionB) {
                return a.name.localeCompare(b.name);
            }

            const partsA = versionA.split('.').map(Number);
            const partsB = versionB.split('.').map(Number);

            const maxLength = Math.max(partsA.length, partsB.length);
            for (let i = 0; i < maxLength; i++) {
                const partA = partsA[i] || 0;
                const partB = partsB[i] || 0;

                if (partA < partB) return -1;
                if (partA > partB) return 1;
            }
            return 0;
        }

        async function loadScripts() {
            const container = document.getElementById('scripts-container');

            container.addEventListener('click', (event) => {
                if (event.target.type === 'checkbox') {
                    handleCheckboxClick(event);
                }
            });

            try {
                const response = await fetch(`${VERCEL_API_URL}/list-scripts`);
                if (!response.ok) throw new Error('Falha ao buscar a lista de scripts.');
                
                const scripts = await response.json();
                scripts.sort(customVersionSort);

                if (scripts.length === 0) {
                    container.innerHTML = '<p>Nenhum script UPDATE_*.sql encontrado.</p>';
                    return;
                }

                container.innerHTML = '';
                scripts.forEach(script => {
                    const checkboxHTML = `
                        <div class="form-check script-item">
                            <input class="form-check-input" type="checkbox" value="${script.path}" id="chk-${script.name}">
                            <label class="form-check-label" for="chk-${script.name}">${script.name}</label>
                        </div>`;
                    container.innerHTML += checkboxHTML;
                });
            } catch (error) {
                console.error(error);
                container.innerHTML = '<p class="text-danger">Erro ao carregar scripts.</p>';
            }
        }

        async function generateUnifiedScript() {
            const btn = document.getElementById('btn-gerar');
            const checkedBoxes = document.querySelectorAll('#scripts-container input[type="checkbox"]:checked');

            if (checkedBoxes.length === 0) {
                Swal.fire('Atenção', 'Selecione pelo menos um script.', 'warning');
                return;
            }

            btn.disabled = true;
            btn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Compactando...';

            try {
                const filesToFetch = Array.from(checkedBoxes).map(chk => ({
                    path: chk.value,
                    name: chk.labels[0].textContent.trim()
                }));

                const scriptContents = await Promise.all(
                    filesToFetch.map(file =>
                        fetch(`${VERCEL_API_URL}/get-script-content?path=${encodeURIComponent(file.path)}`)
                        .then(res => {
                            if (!res.ok) throw new Error(`Falha ao baixar ${file.name}`);
                            return res.json(); // 1. Espera uma resposta JSON
                        })
                        .then(async (data) => {
                            // 2. Decodifica o Base64 para um ArrayBuffer
                            const fetchRes = await fetch(`data:application/octet-stream;base64,${data.content_base64}`);
                            const buffer = await fetchRes.arrayBuffer();
                            
                            // 3. Usa o encoding detectado pelo servidor para obter o texto limpo
                            const decoder = new TextDecoder(data.detected_encoding);
                            return decoder.decode(buffer);
                        })
                    )
                );

                let unifiedSqlContent = [
                    '\\set ON_ERROR_STOP on',
                    '',
                    'BEGIN;',
                    ''
                ];

                scriptContents.forEach((content, index) => {
                    const fileName = filesToFetch[index].name;
                    unifiedSqlContent.push(`/*=====${fileName}=====*/`);
                    unifiedSqlContent.push(content.trim() + ';');
                });

                unifiedSqlContent.push('', '', 'COMMIT;');
                const finalSqlString = unifiedSqlContent.join('\r\n');

                const batchContent = `@echo off
setlocal
chcp 65001 > nul
set "DB_USER=suporte"
set "DB_NAME=docwin"
set "PSQL_PATH=%SERVIDORDOC%\\bin\\psql.exe"
set "TEMP_ENCODING_FILE=db_encoding.tmp"
set "SCRIPT_UTF8=ScriptsUnificados_utf8.sql"
set "SCRIPT_WIN1252=ScriptsUnificados_win1252.sql"
if not defined SERVIDORDOC (
    echo.
    echo [ERRO] A variável de ambiente SERVIDORDOC não está definida.
    echo        Certifique-se de que o PostgreSQL esteja instalado e configurado.
    echo.
    pause
    exit /b 1
)
if not exist "%PSQL_PATH%" (
    echo.
    echo [ERRO] O executável psql.exe não foi encontrado em:
    echo "%PSQL_PATH%"
    echo.
    pause
    exit /b 1
)
echo.
echo --- Verificador e Executor de Scripts SQL ---
echo.
echo Tentando identificar o encoding do banco de dados '%DB_NAME%'...
"%PSQL_PATH%" -U %DB_USER% -d %DB_NAME% -t -c "SELECT pg_encoding_to_char(encoding) FROM pg_database WHERE datname = '%DB_NAME%';" > "%TEMP_ENCODING_FILE%" 2>nul
if %errorlevel% neq 0 (
    echo.
    echo [ERRO] Falha ao conectar ao banco de dados ou executar a consulta.
    echo        Verifique as credenciais, o nome do banco e se o serviço do PostgreSQL está ativo.
    del "%TEMP_ENCODING_FILE%" >nul 2>nul
    echo.
    pause
    exit /b 1
)
set /p DB_ENCODING=<"%TEMP_ENCODING_FILE%"
del "%TEMP_ENCODING_FILE%"
for /f "tokens=* delims= " %%a in ("%DB_ENCODING%") do set "DB_ENCODING=%%a"
echo Encoding detectado: %DB_ENCODING%
echo.
set "SCRIPT_TO_RUN="
if /I "%DB_ENCODING%"=="UTF8" (
    echo Selecionando script para UTF-8...
    set "SCRIPT_TO_RUN=%SCRIPT_UTF8%"
    chcp 65001 > nul
) else if /I "%DB_ENCODING%"=="WIN1252" (
    echo Selecionando script para WIN-1252...
    set "SCRIPT_TO_RUN=%SCRIPT_WIN1252%"
    chcp 1252 > nul
) else (
    echo.
    echo [AVISO] Encoding não reconhecido: '%DB_ENCODING%'.
    echo         Não foi possível determinar o script correto para executar.
    echo.
    pause
    exit /b 1
)
if not exist "%SCRIPT_TO_RUN%" (
    echo.
    echo [ERRO] O arquivo de script '%SCRIPT_TO_RUN%' não foi encontrado.
    echo.
    pause
    exit /b 1
)
echo.
echo Executando: "%SCRIPT_TO_RUN%"
echo -------------------------------------------------
"%PSQL_PATH%" -U %DB_USER% -d %DB_NAME% -f "%SCRIPT_TO_RUN%"
if %errorlevel% neq 0 (
    echo.
    echo -------------------------------------------------
    echo [ERRO] Ocorreu um erro durante a execução do script SQL.
    echo.
) else (
    echo.
    echo -------------------------------------------------
    echo [SUCESSO] Script SQL executado com sucesso.
    echo.
)
pause
endlocal
exit /b 0
`.replace(/\n/g, '\r\n');

                const response = await fetch(`${VERCEL_API_URL}/generate-exe`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        batContent: batchContent,
                        sqlU8Content: finalSqlString,
                        sqlW1252Content: finalSqlString, // Assuming the same content for now, encoding handled by the API
                    }),
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || 'Falha ao gerar o executável.');
                }

                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = 'ScriptsUnificados.exe';
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                a.remove();

                Swal.fire('Sucesso!', 'O arquivo ScriptsUnificados.exe foi gerado e baixado.', 'success');

            } catch (error) {
                console.error(error);
                Swal.fire('Erro', 'Não foi possível gerar o arquivo .zip.', 'error');
            } finally {
                btn.disabled = false;
                btn.innerHTML = 'Gerar Script';
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            applyModalTheme();
            loadScripts();
        });
    </script>
</body>
</html>